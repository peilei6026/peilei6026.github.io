<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>裴雷de博客</title>
  
  <subtitle>只争朝夕 不负韶华</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://peilei6026.github.io/"/>
  <updated>2020-07-03T13:17:47.857Z</updated>
  <id>https://peilei6026.github.io/</id>
  
  <author>
    <name>裴雷</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>免死金牌？不存在的</title>
    <link href="https://peilei6026.github.io/2020/07/03/%E5%85%8D%E6%AD%BB%E9%87%91%E7%89%8C%EF%BC%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84/"/>
    <id>https://peilei6026.github.io/2020/07/03/%E5%85%8D%E6%AD%BB%E9%87%91%E7%89%8C%EF%BC%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84/</id>
    <published>2020-07-03T12:41:09.000Z</published>
    <updated>2020-07-03T13:17:47.857Z</updated>
    
    <content type="html"><![CDATA[<p>黄马褂，尚方宝剑，免死金牌，丹书铁卷都是我们在古装剧或者古代题材文学作品种耳熟能详的道具，他们共同的特点就是可以当作[护身符]来使用，关键时刻可以保命。在历史上，具备这种[护身符]功能的东西确实存在的，只不过他的换现能力往往并不能令人满意，有时反而会为主人招来杀身之祸。</p><h1 id="拉钩上吊一百年，不许变"><a href="#拉钩上吊一百年，不许变" class="headerlink" title="拉钩上吊一百年，不许变"></a>拉钩上吊一百年，不许变</h1><p>[拉钩上吊一百年，不许变]是我们小时候每个人都听说过的童谣，[吊]在古代是铜钱的量词，比如[一吊钱]这种说法。古时候的铜钱不好保管，人们就用绳子将其串起来使用，[上吊]因此就演变成了[把某事说定，不改了]的意思，不过这毕竟看起来有点[小儿科]，皇帝们承诺方式看上去高大上很多。</p><h1 id="中国最早的-铁卷"><a href="#中国最早的-铁卷" class="headerlink" title="中国最早的[铁卷]"></a>中国最早的[铁卷]</h1><p>作为皇帝犒赏，笼络皇亲国戚,朝廷重臣的一种手段，从汉高祖刘邦开始颁发一些优待或者减免刑罚的[铁卷]，一般为铁制成的，外形类似瓦片，最早用丹砂填字，因此成为[丹书铁卷]。刘邦的铁卷赐给韩信仅仅五年后，就把韩信杀了，据司马迁统计，汉朝受过[铁卷]封赏的百余人中，仅有五人得已善终。</p><h1 id="海誓山盟也不好使"><a href="#海誓山盟也不好使" class="headerlink" title="海誓山盟也不好使"></a>海誓山盟也不好使</h1><p>据&lt;资治通鉴&gt;记载，武则天晚年担心自己去世后，皇太子李显会清算武性的娘家人，于是要求皇太子等李姓皇族发誓与武家和平相处。她[告天地于名堂，铭之铁卷，藏之史馆]。然而尽管有天地作证，有海誓山盟，有铁卷铭文，武则天死后，几乎所有身居要职的武家人还是难逃一死。</p><h1 id="最著名的-丹书铁卷"><a href="#最著名的-丹书铁卷" class="headerlink" title="最著名的[丹书铁卷]"></a>最著名的[丹书铁卷]</h1><p>读过水浒传的一定都对[小旋风]柴进的[丹书铁卷]，印象深刻，正因为有了这块[护身符]，他才敢广收江湖上各路被通缉的好汉，在梁山上威望极高，坐第十把交椅，柴进的祖上柴宗训是五代十国后周的最后一位皇帝，赵匡胤正式从他的手中[黄袍加身]，夺取了江山，并给柴式后人颁发了[丹书铁卷]。</p><h1 id="说话算数的皇帝"><a href="#说话算数的皇帝" class="headerlink" title="说话算数的皇帝"></a>说话算数的皇帝</h1><p>与其他皇帝不同，赵匡胤给柴氏后人颁发了[丹书铁卷]后，竟能说到做到，柴宗训死时，赵匡胤甚至[素服发哀，辍朝十日]，此外赵匡胤说过的[不得杀士大夫以及上书言事人]还给天下所有读书人发了[免死金牌]。如果没有这句话，苏轼或者在[乌台诗案]就会掉了脑袋，也就不会有&lt;赤壁赋&gt;等千古名篇了。</p><h1 id="死亡通知单"><a href="#死亡通知单" class="headerlink" title="死亡通知单"></a>死亡通知单</h1><p>在一群出生入死的文成武将的帮衬下，朱元璋这个要饭的和尚终于成了明朝的开国皇帝，登基不久，他向六名公爵，二十八名侯爵颁发了[丹书铁卷]。经过大部分功臣们依旧小心翼翼的或者，但还是最终难逃明太祖的猜忌，一张张[丹书铁卷]变成了一道道[催命符]，开国功臣中几乎无人善终。</p><h1 id="免死金牌再多也没有用"><a href="#免死金牌再多也没有用" class="headerlink" title="免死金牌再多也没有用"></a>免死金牌再多也没有用</h1><p>还是明朝，天启年最臭名昭著的大太监魏忠贤排除异己，独揽朝政，最得势的时候号称[九千九百岁]，[铁卷叠颁]说的就是当时朝廷颁发了好几块[免死金牌]给他，然而崇祯皇帝一登基就治了他十大罪，最终吓得他上吊自杀，可见明朝的[免死金牌]更像是[招灾牌]，还是离得越远越好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;黄马褂，尚方宝剑，免死金牌，丹书铁卷都是我们在古装剧或者古代题材文学作品种耳熟能详的道具，他们共同的特点就是可以当作[护身符]来使用，关键时刻可以保命。在历史上，具备这种[护身符]功能的东西确实存在的，只不过他的换现能力往往并不能令人满意，有时反而会为主人招来杀身之祸。&lt;/
      
    
    </summary>
    
    
    
      <category term="杂谈" scheme="https://peilei6026.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>男生要不要留胡子</title>
    <link href="https://peilei6026.github.io/2020/07/02/%E7%94%B7%E7%94%9F%E8%A6%81%E4%B8%8D%E8%A6%81%E7%95%99%E8%83%A1%E5%AD%90/"/>
    <id>https://peilei6026.github.io/2020/07/02/%E7%94%B7%E7%94%9F%E8%A6%81%E4%B8%8D%E8%A6%81%E7%95%99%E8%83%A1%E5%AD%90/</id>
    <published>2020-07-02T14:30:24.000Z</published>
    <updated>2020-07-02T15:46:53.642Z</updated>
    
    <content type="html"><![CDATA[<p>胡子和战争有什么关系？希特勒和日本人的小胡子有什么讲究？胡子的款式是如何变迁的？</p><h1 id="男人们开始刮胡子了-新石器时代"><a href="#男人们开始刮胡子了-新石器时代" class="headerlink" title="男人们开始刮胡子了-新石器时代"></a>男人们开始刮胡子了-新石器时代</h1><p>据考证，早在新石器时代，人类就开始用磨光了的石头，贝壳等工具刮胡子，确切点说应该更像是[锯]胡子，找不到合适工具的时候他们甚至会用火烧掉胡子，这样做主要是为了减少虱子，跳蚤等小虫子的寄生。铜器出现之后，有了锋利轻便的趁手工具，男性们就更加热衷于让自己的下巴变得更加光滑。</p><h1 id="输了就得要听人家的-古罗马-士兵不能留胡子"><a href="#输了就得要听人家的-古罗马-士兵不能留胡子" class="headerlink" title="输了就得要听人家的-古罗马  士兵不能留胡子"></a>输了就得要听人家的-古罗马  士兵不能留胡子</h1><p>在西方，从亚历山大大帝开始，他要求自己的士兵平时必须把脸刮干净，以免战场上徒手搏斗的时候被对方抓住胡子，这一习俗一直保持到古罗马时期，罗马皇帝屋大维和凯撒都是不留胡子的。后来，留着大胡子，被视为野蛮人的日耳曼人击败了罗马人，男人们又重新留起来象征威武的大胡子。</p><h1 id="还是别留胡子了-天主教-矛盾的天主教的神职人员"><a href="#还是别留胡子了-天主教-矛盾的天主教的神职人员" class="headerlink" title="还是别留胡子了-天主教 矛盾的天主教的神职人员"></a>还是别留胡子了-天主教 矛盾的天主教的神职人员</h1><p>由于耶稣就是留着胡子的形象，因此基督教徒们大多蓄须。在中世纪欧洲，胡须是判断男性是否到了婚育年龄的标准，而天主教的神职人员却都是终生不能结婚的。为了化解这一尴尬和矛盾，天主教廷正式规定神职人员必须定期刮胡子。由于神职人员的崇高地址，普通男性夜开始刮起了胡子，蓄须则再次成为了野蛮，贫穷的象征。</p><h1 id="纠结的沙皇们-俄罗斯"><a href="#纠结的沙皇们-俄罗斯" class="headerlink" title="纠结的沙皇们-俄罗斯"></a>纠结的沙皇们-俄罗斯</h1><p>在同一时期，信奉东正教居多的东欧国家则坚持蓄须的原则。俄罗斯首位沙皇伊凡四世就觉得俄罗斯人若像西方人那样剃去胡须是一种不可饶恕的罪孽，是对上帝赐予的面容的侮辱，然而到了他的后代彼得一世的，又认为还是下巴光滑的男性看起来比较顺眼，并对想要留胡子的男性开征[胡须税]，从此俄罗斯人的脸上也变得干净了。</p><h1 id="胡子象征权威"><a href="#胡子象征权威" class="headerlink" title="胡子象征权威"></a>胡子象征权威</h1><p>克里米亚战争中，由于没有时间刮胡子，取胜归国的英军士兵们大多是大胡子，一时间蓄须重新风靡欧洲。随后不久，德皇威廉一世登基，他标志性的[海豹胡]也成为了权威的象征，他的孙子威廉二世觉得[海豹胡]还不足以张杨自己的个性，他把胡须两端向上高高翘起，形成了更张扬的[牛角胡]。</p><h1 id="引领中国风潮-俾斯麦"><a href="#引领中国风潮-俾斯麦" class="headerlink" title="引领中国风潮-俾斯麦"></a>引领中国风潮-俾斯麦</h1><p>德国[铁血宰相]俾斯麦也已[海豹胡]的形象示人，他的海豹胡甚至影响到了中国的北洋军阀们。袁世凯，段祺瑞，张作霖，曹锟等大军阀全都以[海豹胡]示人，后来，由于奥地利帝国要求官员必须剃胡子并露出下巴，作为对立，改革派和革命派人士纷纷留起了大胡子，其中以马克思，恩格斯尤为明显。</p><h1 id="鬼子们的卫生胡-日本"><a href="#鬼子们的卫生胡-日本" class="headerlink" title="鬼子们的卫生胡-日本"></a>鬼子们的卫生胡-日本</h1><p>为了方便打理，以希特勒为代表的欧洲人率先发明了[卫生胡]。日本明治维新后开始全盘西化，同为二元制君主立宪国家的德国成了日本的首选目标，因此[卫生胡]也传到了日本。[卫生胡]显示在日本的武士阶层流行起来，而到了军国主义盛行的昭和年间，崇尚[武士道]的日本军人也纷纷留起了这种胡子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;胡子和战争有什么关系？希特勒和日本人的小胡子有什么讲究？胡子的款式是如何变迁的？&lt;/p&gt;
&lt;h1 id=&quot;男人们开始刮胡子了-新石器时代&quot;&gt;&lt;a href=&quot;#男人们开始刮胡子了-新石器时代&quot; class=&quot;headerlink&quot; title=&quot;男人们开始刮胡子了-新石器时
      
    
    </summary>
    
    
    
      <category term="杂谈" scheme="https://peilei6026.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>文字简说</title>
    <link href="https://peilei6026.github.io/2020/07/01/%E6%96%87%E5%AD%97%E7%AE%80%E8%AF%B4/"/>
    <id>https://peilei6026.github.io/2020/07/01/%E6%96%87%E5%AD%97%E7%AE%80%E8%AF%B4/</id>
    <published>2020-07-01T14:16:45.000Z</published>
    <updated>2020-07-01T15:23:42.631Z</updated>
    
    <content type="html"><![CDATA[<p>简述：拼音是怎么来的？右左怎么变成了左右？鸟怎么就不是鸟儿了？<br>内容简介：汉字是中国人的文字，拼音是汉字的注音，图像是文字曾经的样子，从左到右是汉字排版的方向。这是如今我们所熟悉的汉字，却不是它曾经的样子，作为上古时期各大文字体系中唯一传从到今的文字，汉字都经历了怎样的故事呢？</p><h1 id="上古结绳而治"><a href="#上古结绳而治" class="headerlink" title="上古结绳而治"></a>上古结绳而治</h1><p>在尚未发明文字的时候，上古时代的人类祖先们采用结绳记事，大事大结，小事小结，这不是中国人的专利，非洲和南美洲等地也曾使用这种方法，马克思就曾在自己的书里面记载过印第安人的结绳记事：是用一种各色贝珠穿成的绳子，一定的珠串与一定的事实相联系，只有经过训练的人才能解读。</p><h1 id="世上最古老的文字"><a href="#世上最古老的文字" class="headerlink" title="世上最古老的文字"></a>世上最古老的文字</h1><p>后来，人们开始用图画的形式记录交流信息，进而演化出了象形文字，包括埃及的象形文字，赫梯象形文，苏美尔文，古印度文以及中国的甲骨文，苏美尔人的楔形文字是已知世界上最古老的文字，在2000年间一直是美索不达米亚地区唯一的文字体系，到了公元前500年左右，楔形文字甚至成为了西亚大部分地区通用的商业交往媒介。</p><h1 id="中国最古老的文字"><a href="#中国最古老的文字" class="headerlink" title="中国最古老的文字"></a>中国最古老的文字</h1><p>甲骨文作为象形文字的一种，是现存在最早可识别的成熟汉字体系，有些甲骨文中的字还具有或多或少的象形图画的痕迹，但从已识别的约2000个甲骨文单字来看，它已具备[象形，形声，指事，转注，假借]的造字方法。</p><h1 id="世界上最早的拼音"><a href="#世界上最早的拼音" class="headerlink" title="世界上最早的拼音"></a>世界上最早的拼音</h1><p>有意思的是，汉字的[象形]与古西方的[象形]并不完全相同。事实上，古埃及文字中绝大部分图画符号并非以行表意，而是表音，更类似于字母文字，举个例子来说，在古埃及文字语法中，看起来像是各种鸟的符号，其实跟鸟无关，而是表示不同的发音，所以，[古埃及象形文字]其实是世界上最早的拼音文字。</p><h1 id="中国最早的拼音"><a href="#中国最早的拼音" class="headerlink" title="中国最早的拼音"></a>中国最早的拼音</h1><p>中国原来是没有拼字字母的，人们采用同音字或者两个汉字来给另一个字注音。明朝末年，玛窦等西方传教士来中国，为了学习汉字开始用拉丁字母来拼写汉语。而中国自己的汉语拼音运动是清朝年末开始的，鸦片战争以后，梁启超等爱国知识分子提出了教育救国的主张，指出汉字的繁难是教育不能普及的原因，掀起了[切音字运动]。</p><h1 id="世界上最早的书写方向"><a href="#世界上最早的书写方向" class="headerlink" title="世界上最早的书写方向"></a>世界上最早的书写方向</h1><p>文字在记录口语的时候，必然随着口语的顺序进行，但是把口语唯一的时间顺序转换成空间顺序的时候会遇到很多种选择。在早期文字中，书写方向就比较随性，例如埃及圣书体，一般是写到哪儿就从哪儿继续，叫做牛耕式写法，也就是[蛇形走位]</p><h1 id="中国字的-转向"><a href="#中国字的-转向" class="headerlink" title="中国字的[转向]"></a>中国字的[转向]</h1><p>传统汉字右起竖写，很可能是因为方便，因为早期以竹简著书，左手拿起右手拉开阅读或书写都比较顺手，而西方文化引进以后，在用一篇文章中就出现了竖着的中国字和横行的外国公式，阅读起来非常不便。中华国民精英们就此进行了大讨论，不过识字的人是在太少，此事便罢了，直到新中国成立后的文字改革，汉字才成立如今的样子。</p><h1 id="横竖的差别大了"><a href="#横竖的差别大了" class="headerlink" title="横竖的差别大了"></a>横竖的差别大了</h1><p>当时的人们&lt;新青年&gt;上的热火朝天，还进行了一个实验：同一个人读同样的文字，一个横排一个竖排，读完了横排版用了35秒，而读竖排版用了50秒，掐指一算，按照这个速度读横排的《水浒传》要11天7小时，竖排的要用16天7小时，[若按照这么来想，吾们天天看报章读书籍，只因为排版不得法，不知空费了吾们多少光阴！]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简述：拼音是怎么来的？右左怎么变成了左右？鸟怎么就不是鸟儿了？&lt;br&gt;内容简介：汉字是中国人的文字，拼音是汉字的注音，图像是文字曾经的样子，从左到右是汉字排版的方向。这是如今我们所熟悉的汉字，却不是它曾经的样子，作为上古时期各大文字体系中唯一传从到今的文字，汉字都经历了怎样
      
    
    </summary>
    
    
    
      <category term="杂谈" scheme="https://peilei6026.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>啤酒中的战斗机,精酿啤酒</title>
    <link href="https://peilei6026.github.io/2020/06/29/%E5%95%A4%E9%85%92%E4%B8%AD%E7%9A%84%E6%88%98%E6%96%97%E6%9C%BA-%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92/"/>
    <id>https://peilei6026.github.io/2020/06/29/%E5%95%A4%E9%85%92%E4%B8%AD%E7%9A%84%E6%88%98%E6%96%97%E6%9C%BA-%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92/</id>
    <published>2020-06-29T15:01:15.000Z</published>
    <updated>2020-06-29T15:27:02.951Z</updated>
    
    <content type="html"><![CDATA[<p>啤酒是人们日常生活中非常重要的一种饮品，历史悠久，且受众广泛，然而在大众啤酒百年不变且日趋饱和的大背景下，精酿啤酒市场被越来越多的人来看好，而精酿啤酒千奇百怪的创作，口味，以及外观，也开始收到更多人的追平和喜爱，那么这种精酿啤酒是谁创造出来的呢？所谓精酿到底是什么呢？和大众啤酒又有什么区别呢？</p><h1 id="什么是精酿"><a href="#什么是精酿" class="headerlink" title="什么是精酿"></a>什么是精酿</h1><p>精酿是相对于大规模生产的工业啤酒而言的一种品质较高的啤酒，而工业啤酒通俗的说，就是百威，喜力，雪花，燕京，青岛，科罗娜等等平时随处可见的大牌子，味道寡淡，酒精度低，包装高度统一。</p><h1 id="精酿从何而来"><a href="#精酿从何而来" class="headerlink" title="精酿从何而来"></a>精酿从何而来</h1><p>精酿啤酒的概念是美国人发起的，引用美国酿造者协会BA对精酿酿造者的要求就是：一要小，年产量小于600万桶（95.388万吨),生产的啤酒用于商业交易，二要独立自主，非精酿酿造者或公司机构，且占股份不能超过25%；三要遵循传统，酿造者所酿造的大部分啤酒的风味都应该是从传统的原料与发酵工艺中获得。</p><h1 id="工业啤酒为什么【水】"><a href="#工业啤酒为什么【水】" class="headerlink" title="工业啤酒为什么【水】"></a>工业啤酒为什么【水】</h1><p>首先原料不同，工业啤酒为了啤酒的稳定性和控制成本，往往会在酿造的过程中加入大量的玉米，淀粉和酶制剂等，使得口感十分寡淡。而精酿只用麦芽，啤酒花，酵母和水，不会添加添加剂，只有时会加入一点橙皮，香菜籽，海盐等辅料，来增加啤酒的特色和风味。</p><h1 id="为什么精酿啤酒更为浓郁？"><a href="#为什么精酿啤酒更为浓郁？" class="headerlink" title="为什么精酿啤酒更为浓郁？"></a>为什么精酿啤酒更为浓郁？</h1><p>工业啤酒是一般是拉个酵母低温发酵，为了提高产品和控制时间成本，发酵周期很短，只有七天左右，而精酿啤酒相对比较高端，不会有过多考虑成本的问题，而是让啤酒充分发酵，这样含有的麦芽汁浓度也就更好了，口味也就更加浓郁。</p><h1 id="精酿是怎么酿的？"><a href="#精酿是怎么酿的？" class="headerlink" title="精酿是怎么酿的？"></a>精酿是怎么酿的？</h1><p>艾尔工艺，是将酵母放在发酵罐的顶端来进行发酵，发酵温度需要严格把控在10-20度，采用的发酵罐一般会比较小，发酵完成后不会进行过滤和杀菌，而工业啤酒采用的是拉个工艺酿造，和精酿啤酒几乎完全相反，在发酵罐底部进行发酵，温度控制在10度以下，完成后及进行过滤和杀毒，以保鲜时间。</p><h1 id="这些都是什么千奇百怪的味道"><a href="#这些都是什么千奇百怪的味道" class="headerlink" title="这些都是什么千奇百怪的味道"></a>这些都是什么千奇百怪的味道</h1><p>精酿啤酒的更温暖的环境中发酵，并且有成百上千中不同的菌株，依靠不同的菌株，从而产生大量的酯类和其他的一些特殊香味，一些情况下有苹果，凤梨，香蕉，梅子，李子等味道，当然，有些精酿也会主动添加一些不同的佐料，如巧克力，咖啡，水果甚至是木头来调味</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;啤酒是人们日常生活中非常重要的一种饮品，历史悠久，且受众广泛，然而在大众啤酒百年不变且日趋饱和的大背景下，精酿啤酒市场被越来越多的人来看好，而精酿啤酒千奇百怪的创作，口味，以及外观，也开始收到更多人的追平和喜爱，那么这种精酿啤酒是谁创造出来的呢？所谓精酿到底是什么呢？和大众
      
    
    </summary>
    
    
    
      <category term="杂谈" scheme="https://peilei6026.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>离校循环单</title>
    <link href="https://peilei6026.github.io/2020/06/21/%E7%A6%BB%E6%A0%A1%E5%BE%AA%E7%8E%AF%E5%8D%95/"/>
    <id>https://peilei6026.github.io/2020/06/21/%E7%A6%BB%E6%A0%A1%E5%BE%AA%E7%8E%AF%E5%8D%95/</id>
    <published>2020-06-21T02:44:49.000Z</published>
    <updated>2020-06-22T05:18:50.516Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="56同学请联系刘哥" />    <label for="pass">56同学请联系刘哥</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX182cWycbH97HgCsGVrWR9VFkGrLWNiYwsdEWVXN5686Yp2Voi9aQP4L8+VqsvsIIwY1cIWQkmqZmi6orpatKEbMWywlGwfHV9iljpgxhZR/IwsGig0jug4bhSOQ7NJDOqyB/vS1n2X6/Apbpn4aSLAXNJRdOEmw8bcY2h/m1enYNea4K6i5QKP96fkPv1sahENiJ0S2HFyxt6ohlttS/VHNIn52t7ilC+vKt1bB8CuS8rOnSpvudi57VniBVjNZRmgjEQUstDy8hE6xFGCnfNF7w7RvQrTSoejR7W4ybpfBHG49StMQolTBk3hxF+0oRwogUqCALokHp2myfG7ASgKsJathTjh9NNb7ao9rZCkF9LLiQ/7PgcYkBWae2IiK3tcExeGWz/ZnYlJuzk3lgaASwkCrm1f2Aah2NFpcjpyJGy4y9lQbgpVhLJVQeE5XCAWeA2PW013RrtwWfnSsFLSeiSR4zt7VdktCck3f62D9eV4hCLZ+u2ZJ8yATUcSmImJ98RUrUSPrFoXsFlZFINvLdHRNW38iHpE2/kd1+aW6a1q5AgJzngC5a78qFp9rwT1cVcinVgumstRU1fMEXr+GeP7Vt3O7P2DPBygrlEtt/YHusTv/kte9paNkxiwEQXHUvQg7iaF7b/ivxHewmQjLm79y78lO4Gq68M31RMI2M7J1bYlXBmz045U1xNyDMFEQb7sjqIE7KdtVvhmmF7T1ftJ4vBfknYbqalQ9WeWxot2FXBcp159UiaH9ZBWcBfB2XnCOPCADo9gCEonew2meGogX9Zhok1JOXY/qM1H1gRaObcc5iJQDg/EyT9/xDQbBoFYZJttyx0S0wuBP0e0XX8/fJqd8KNVl11AAgyluiZ5VcTO/ae5FD2jM4LzjjL3Nd7MdgsLunF8AcxiErYx3YQWe3Kt0iX1zswCPhgHLWPMs2sR9YrjSaOxGhafr58ELYUJwIzYTSdwueNjydlY56O6jHlRLBQwJiClgEtfnkelPUp2Z3Pba6o1vMdP7zT5fKU34o1IdjeT+agCSJMf8s8bKvKUJZwgTfPDWV5qRid2i01DqpZH9UA+cmjW+BR6SeMUtIiUjp+j+j0MDEXVptjyFUu0k/qG+tetRrukCiY9S+hQc+pPPMeqHTNfBPlU8ZLA7C6qnfJruNRe1nN5zATPbLFH8Aq1tL7GFrgPmswEkyA2xwSSm5D1U64zK+wDsM4wxrkFJR4QvwqViWCRrkkeAsp24cNiafGgjr/n7Rc+QjCQ1ZkvRcIElCgj8PCOn1NQw+CxDxfCTlqWxn/ABwIbNKfJ/+ZvCGqnbqjKKWCRoqOpJKfVfRY+H/XpQaEfJnF0pA/wWXJ2wytn0KSjcqgPc6s/7LUsX0YvzwlBmmhjKfEe31Z/mVmEApX/mdCqHl895s0smjvv6zJi3VvjMHFsy4RqJCKGjA8HnWKYnUbQggKbYZkbc+p/cJAc2D91XzMyXaxHEkVYgh9cbsWZ24wgVsouaKbCKC0JvBh26taBSM9qKWj/uEw1drwvfybHAvFXg3zvcmCDbVWpUg93aKVgIXNRJk7Pd8OXI2uoapLGeE2L87ghhsPAUXMNWee4WV48VhKBJb8JZUcoTBiRexEd9MNcnMQGO4jGAmOnJYeGX5y9MV0UP7ljJDfF5PWv6rOHMWC2F719/Oz1k/QipFXLEmznv+l7uPiI/+Ozxd2KyXeLlyFr0WQPIro7ny4iaHFm+gulUi5rH/cKmZWWzjmSHXUwWamg8AoOoS0jf8JH36thJ/z7DKoHQsFRnGkSHrYmXV/X28lM+y3x39xNjGBt4TT5mI6w240qNfzLHDWXgGQGFdoUfTsI+wmaCe118XJpB34fDGTOwlSgfHaFCQ9w2hoZlVtw18uVfuJYSn3OIrWiuO3HccvDQzCEzqtKv5lWe1FD8sJ8yaM+IvbNZwMBr6Bd+UaNGBNPYBLsf7asOjKbjHVaFWCpkUJIf7dMkjxEnJYbClvOlfeEefNKAEi4YoCAhkbR1yvjEj3gCsh6x2R9w0qtlkb1wEMmtOqX3KIl+k63z4DLpC4x/48upVh5qFJskiCA7nUQ2sTcYsNDWvRHyXjJ0cos5jCr+SG1I75cCxFJ2msaJBPY9E7GrhC13XB7ENupRaqiGii7nDc6VYyF2I18MDVlhZPi80+hGPa5uw1SngmJfFPlUSN4gRvgowqQsKZXRcapiXyehWgI/a9dbLadALxoFDsAlvMIkapIgmUl+ePashYtSZKOkoLlwJywxr3Z7QsEFokk6RJGxKanpWoKevOj1MSfE3DYBkJN++5s2AuzHowFEd4r9EsCQ1vD5Laq7qlWjFeI+HvCTevTyVTb3fU4lFPkLgfsTyId254ZH87hSqhlBuR4UIxPi2Mmfkop5crN7Cr9YXXNjpUpNvG1UgEKqXrcJhfC3kgmmf3pcgkuaRnWKM13t8I2RApyDvVgEHjFWyNvLDyCPqNTiQ8ENjg4JycuoHKKU2Jjxny1zWxnTtOt1Sl+aXNvtYpxFQBb1jb/PCYyV/qTMUyRcJk5Ry+lpXUvnxiU6B/DfTIK6vxw/p1VZT5MKjt1SH8MgRdUDGT0Mra9+jUT2dlwgQyJb48meJUp3/dwb4hRMjwUX0WpnBe4Dmr2I9SQtCEjDDKAGcYjTq6ToN+7CpKwp+U9N8UsszTX8kDg9HSmBk6LMZ1acmB308L/NGxd84xLUYkYHhTOPKWozPLZraCv1qZHQiEBwXDbGqbLutmdM5tyksQeo0AurNu22EaqopIqLWCynQuhu5mC+vOIsJlp3Q9p+y8FMs+Lpunflgf4vDcOnMoLGS88Eotq89Pf5jyYIWzzf9Bi0Viy04Jhx1frfM2lj0OPgXme2fAtEwpyNqIx887XZOqMHxg1WpZcMh71uoYfHbo46geBLDL9jPoXjKIoWBfSvrvE2q9pUfvSWVkzF9hi0xyKYTLL1TCKhpHNtcMZ2WH4inzFPo5v1TC7uf+DgrZf+VrBhME1v333OsiRJiF8jMRzRuaCxm8ENuJda5ZNKsm5kZErjNTzMt1Tp1vNUvXe0byi7M7cHa3Uby9InKf3BIe2KZ3oipJvbhJ8lPaudiAw67x0H8//qML51xza9JUR54TNZk2NT3TgBn/vKAV0XOT3yI2X2mO+Wz6Yr/Iiv9iHHdddsgDEn4tgygyozN0xm7caXxtIpvFrBU+cT1gbXN7HFsoX14G/bFZu1zjoVFFMNzOuvwKJnPfkqHqCILbGAkQyzOIggQ5hdW5CvAD3xcQYsIxp+2M+yBTZ4uArm+3kKELnGbs2hnzs+P0Ls6E3C8jjAsPy9AL3Xlx2pU0ncMeZSq2m8tj4SMY/0aX2IAZEyreT3ctuViBtnSjp4FuiF6D4Qxg0pIVsvk6DCWD8agHuH+emQR8tGIBdTnGdQ7MQGFxslnSvyalipMYcx6C4t2GN7pAAxHj6UmPAXdI63f6a8Js1rH+uu4DXb8gfLGnp9HmQ8dK8sxb8oA68SqvdwAgd67pA/9EQNzN+5AcWEVeQUgdACu+3lxBSABL+0rHKkiYIk5oLspHrSWA4ulMByXjo6aLyZNK0eRDQlhNvt/+tPBjvkDxOmmOvhIQbYdkZWkuIBYLXWXBSC6gZ7D6uNFDxr954i5KG5QCt3G50WRiDZn3JEFYUgUfk2UsC3bPu3YXiwPuWIZhumlUWLhy7IFeC5F33eVQfnuzo6G6jqo+IHHcH6rUTQbfHmCmYrVXRJ5qtRqBRdsS23zTMl</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      项目过程文档暂不公开，请见谅。
    
    </summary>
    
    
    
      <category term="56项目" scheme="https://peilei6026.github.io/tags/56%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>laravel性能优化</title>
    <link href="https://peilei6026.github.io/2020/06/19/laravel%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://peilei6026.github.io/2020/06/19/laravel%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-19T09:58:06.000Z</published>
    <updated>2020-06-21T14:20:21.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看laravel版本"><a href="#查看laravel版本" class="headerlink" title="查看laravel版本"></a>查看laravel版本</h1><p>php artisan</p><h1 id="开启OPcache"><a href="#开启OPcache" class="headerlink" title="开启OPcache"></a>开启OPcache</h1><p>说明<br>OPcache是由PHP官方公司Zend开发的一款免费使用的PHP优化加速拓展,他可以PHP脚本编译后的bytecode缓存在共享内存中供以后反复使用，从而避免了从磁盘读取代码再次编译的消耗，同时，它还应用了一些代码优化模式，使得代码执行更快，从而加速PHP应用响应。<br>php自从5.5以来，就已经内置了OPcache扩展，不过默认是关闭的状态的，本文讲介绍如何开启OPcache以及在laravel中使用的正确方式。<br>PHP7。2FPM的配置信息位于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;php&#x2F;7.2&#x2F;fpm&#x2F;php.ini</span><br></pre></td></tr></table></figure><p>编辑以上文件，搜索<code>opcache.enable</code>将值设为1即为开机:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcache.enable&#x3D;1</span><br></pre></td></tr></table></figure><p>php.ini 里相关的配置以下，注释里面包括说明和设定的值，请详细阅读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">; 是否在命令行开启，这里默认设置为 0 ，暂且关闭</span><br><span class="line">;opcache.enable_cli&#x3D;0</span><br><span class="line"></span><br><span class="line">; 这个内存是用来存储编译后的字节码的，视你的程序</span><br><span class="line">; 代码量而定，Laravel 应用一般建议设置为 256，单位 MB，</span><br><span class="line">; 默认是 128</span><br><span class="line">opcache.memory_consumption&#x3D;256</span><br><span class="line"></span><br><span class="line">; 会对程序所有的字符串进行统一存储以加快存取速度，</span><br><span class="line">; 默认是 8m，建议 32 或者不超过 64。</span><br><span class="line">opcache.interned_strings_buffer&#x3D;32</span><br><span class="line"></span><br><span class="line">; 最大加速多少个脚本文件，视项目脚本文件数而定，</span><br><span class="line">; 合理区间 200~1000000 ，默认是 10000 ，建议 500000</span><br><span class="line">opcache.max_accelerated_files&#x3D;1000000</span><br><span class="line"></span><br><span class="line">; 最大作废比例百分比，到达这个比例会重启，默认是 5 ，建议 10</span><br><span class="line">opcache.max_wasted_percentage&#x3D;10</span><br><span class="line"></span><br><span class="line">; 开启情况下会在脚本名称前加上当前目录信息做为缓存的 Key，关闭可以</span><br><span class="line">; 提高性能，但是会面临出错的风险（文件名一致时），建议开启，关闭使用 0</span><br><span class="line">opcache.use_cwd&#x3D;1</span><br><span class="line"></span><br><span class="line">; 开启的话，会按照 opcache.revalidate_freq 设置的频率去检查文件</span><br><span class="line">; 是否修改以便重新缓存，默认开启，生产环境下请设置为关闭，然后</span><br><span class="line">; 写自动化脚本，在每次更新代码后自动重启 OPcache</span><br><span class="line">opcache.validate_timestamps&#x3D;0</span><br><span class="line"></span><br><span class="line">; 文件更新检测频率，单位秒，只有在 opcache.validate_timestamps </span><br><span class="line">; 开启时才有效。默认为 2，意味着 2 秒钟检查一次，会对文件系统造</span><br><span class="line">; 成负担，如果是在开发环境中请酌情使用，生产环境随意设置，因为</span><br><span class="line">; 我们会设置 validate_timestamps 为关闭。</span><br><span class="line">opcache.revalidate_freq&#x3D;2200</span><br><span class="line"></span><br><span class="line">; 文件加载的逻辑，默认关闭，无需修改</span><br><span class="line">;opcache.revalidate_path&#x3D;0</span><br><span class="line"></span><br><span class="line">; 开启的话会把代码注释一起缓存，关闭可减低内存使用，但是</span><br><span class="line">; 如果有一些代码依赖于注释里的指令，例如 Doctrine, </span><br><span class="line">; Zend Framework 2 和 PHPUnit，将会出现问题。建议开启</span><br><span class="line">opcache.save_comments&#x3D;1</span><br></pre></td></tr></table></figure><p>修改完成后，需要重启FPM生效:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo service php7.2-fpm restart</span><br></pre></td></tr></table></figure><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>接下来我们使用课程里面安装的ab压测工具试下性能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ab -n 100 -c 2 http:&#x2F;&#x2F;larabbs.test&#x2F;topics</span><br></pre></td></tr></table></figure><p>以上命令以并发数为2的情况发送100请求，得到的结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Requests per second:    11.20 [#&#x2F;sec] (mean) </span><br><span class="line">Time per request:       178.643 [ms] (mean)</span><br><span class="line">Time per request:       89.322 [ms] (mean, across all concurrent requests)</span><br></pre></td></tr></table></figure><p>解释如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 并发数，每秒能处理多少个请求，越多越好</span><br><span class="line">Requests per second:    11.20 [#&#x2F;sec] (mean)</span><br><span class="line"></span><br><span class="line"># 一个并发（这里是 2）处理的时间，单位毫秒，越小越好</span><br><span class="line">Time per request:       178.643 [ms] (mean) </span><br><span class="line"></span><br><span class="line"># 平均每个请求的响应时间，单位毫秒，越小越好</span><br><span class="line">Time per request:       89.322 [ms] (mean, across all concurrent requests)</span><br></pre></td></tr></table></figure><p>接下来尝试OPcache关闭的情况，打开Php.ini将opcache.enable设置为0，然后重启FPM，接着重复上面的ab命令，得到的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Requests per second:    8.80 [#&#x2F;sec] (mean)</span><br><span class="line">Time per request:       227.230 [ms] (mean)</span><br><span class="line">Time per request:       113.615 [ms] (mean, across all concurrent requests)</span><br></pre></td></tr></table></figure><p>可以看到性能有非常显著的提高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查看laravel版本&quot;&gt;&lt;a href=&quot;#查看laravel版本&quot; class=&quot;headerlink&quot; title=&quot;查看laravel版本&quot;&gt;&lt;/a&gt;查看laravel版本&lt;/h1&gt;&lt;p&gt;php artisan&lt;/p&gt;
&lt;h1 id=&quot;开启OPcache&quot;
      
    
    </summary>
    
    
    
      <category term="Laravel" scheme="https://peilei6026.github.io/tags/Laravel/"/>
    
      <category term="优化" scheme="https://peilei6026.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>解决html中&amp;nbsp;在不同浏览器中占位大小不统一的问题</title>
    <link href="https://peilei6026.github.io/2020/06/11/%E8%A7%A3%E5%86%B3html%E4%B8%AD-nbsp-%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%8D%A0%E4%BD%8D%E5%A4%A7%E5%B0%8F%E4%B8%8D%E7%BB%9F%E4%B8%80%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://peilei6026.github.io/2020/06/11/%E8%A7%A3%E5%86%B3html%E4%B8%AD-nbsp-%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%8D%A0%E4%BD%8D%E5%A4%A7%E5%B0%8F%E4%B8%8D%E7%BB%9F%E4%B8%80%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-10T16:59:49.000Z</published>
    <updated>2020-06-10T17:01:06.379Z</updated>
    
    <content type="html"><![CDATA[<p>直接在html文档中使用&nbsp;来表示空格，在不同浏览器中的占位大小是不一样的.</p><p>为什么呢，因为不同浏览器默认的字体是不一样的，不同字体下的空格表示&nbsp;占位大小不一致.</p><p>这就好办了嘛，我们对&nbsp;指定使用同样的字体就能让&nbsp;显示同样的占位了.</p><p>经过测试，当指定 Times New Roman字体时，各浏览器都支持良好，每4个&nbsp;显示的占位是一个汉字字符，而使用宋体或黑体则不能达到目的.</p><p>即：</p><p><span style="font-family:'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p>表示一个汉字字符的占位.</p><p>ps:此方法不对html文档造成其他影响，不需修改编码方式，缺点就是要嵌套标签，匿.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;直接在html文档中使用&amp;nbsp;来表示空格，在不同浏览器中的占位大小是不一样的.&lt;/p&gt;
&lt;p&gt;为什么呢，因为不同浏览器默认的字体是不一样的，不同字体下的空格表示&amp;nbsp;占位大小不一致.&lt;/p&gt;
&lt;p&gt;这就好办了嘛，我们对&amp;nbsp;指定使用同样的字体就能让&amp;nbs
      
    
    </summary>
    
    
    
      <category term="复盘" scheme="https://peilei6026.github.io/tags/%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>万事开头难:如何起一个好的变量名</title>
    <link href="https://peilei6026.github.io/2020/05/21/%E4%B8%87%E4%BA%8B%E5%BC%80%E5%A4%B4%E9%9A%BE-%E5%A6%82%E4%BD%95%E8%B5%B7%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D/"/>
    <id>https://peilei6026.github.io/2020/05/21/%E4%B8%87%E4%BA%8B%E5%BC%80%E5%A4%B4%E9%9A%BE-%E5%A6%82%E4%BD%95%E8%B5%B7%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8D/</id>
    <published>2020-05-20T16:12:40.000Z</published>
    <updated>2020-06-05T14:51:25.116Z</updated>
    
    <content type="html"><![CDATA[<p>学习要注意到细节,不是粗枝大叶得,这样可以逐步学习,摸索,找到客观规律.—徐特立</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>名字是一个人在社会中必不可少的符号雨表示，也是信息表达,交流,传播得一种工具.每当提起一个人得名字,我们总是能联想打对应得人,这就是名字得作用.<br>详细每个人都应该看过小说把,在小说中重要人物名都是很有讲究的,尤其是在好的小说中往往从一个人的名字就能联想到此人的性格和命运.<br>例如：李寻欢,表面有寻欢作乐之意，而他也的确是个放荡不羁又多情的剑客;[君子剑]岳不群,孔子曰:君子矜而不争，群而不党。不群不群,暗示他是个伪君子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let 李寻欢;&#x2F;&#x2F;想必此人是个浪子</span><br><span class="line">let 岳不群;&#x2F;&#x2F;很明显是个伪君子</span><br><span class="line">let 张三;&#x2F;&#x2F;为什么叫张三？长了三只眼？三只手？家里排行老三？</span><br></pre></td></tr></table></figure><p>我扯了这么多小说中的人物名,这和我们今天的主题是不是有关系呢？没错,如果在程序中能有一个好的变量名,对于可维护性和可读性都会有很大的提升。</p><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>由于JS中没有强制规定变量命名规范,比如:匈牙利命名法(数据类型+描述),大驼峰命名法(FirstName),小驼峰命名法(firstName),下划线命名法(first_name).<br>在这篇文章中,我们统一规定一下对类和构造函数应当使用大驼峰命名法,对其他的变量和函数都是用小驼峰命名法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let FirstName;&#x2F;&#x2F;bad</span><br><span class="line">let first_name;&#x2F;&#x2F;bad</span><br><span class="line">let firstName;&#x2F;&#x2F;good</span><br></pre></td></tr></table></figure><h1 id="避免抽象词"><a href="#避免抽象词" class="headerlink" title="避免抽象词"></a>避免抽象词</h1><p>在为变量命名时，要尽量避免抽象的变量名。<br>例如下面这段代码,一眼看上去就摸不着头脑。x,y,xx是什么？谁能知道这段代码是计算净收入的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;bad</span><br><span class="line">let x &#x3D; averlncome * months;</span><br><span class="line">let y &#x3D; averExpense * months;</span><br><span class="line">let xx&#x3D;x - y;</span><br></pre></td></tr></table></figure><p>好的变量名应当易记,能够准确地表达出变量的意义,通常对变量的描述就是最好的变量名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;good</span><br><span class="line">let incomeTotal &#x3D; averlncome * months;</span><br><span class="line">let expenseTotal &#x3D; averExpense * months;</span><br><span class="line">let incomeNet &#x3D; incomeTotal - expenseTotal;</span><br></pre></td></tr></table></figure><h1 id="以问题为导向"><a href="#以问题为导向" class="headerlink" title="以问题为导向"></a>以问题为导向</h1><p>变量命名应该以问题为导向,变量名反应的应该是问题,而不是结果.<br>比如我们计算某几个月的总收入,那么total就比result更好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function calcSalary(averSalary,months)&#123;</span><br><span class="line">    let result &#x3D; averSalary * months;&#x2F;&#x2F;bad</span><br><span class="line">    let total &#x3D; averSalary * months;&#x2F;&#x2F;good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更准确的变量名"><a href="#更准确的变量名" class="headerlink" title="更准确的变量名"></a>更准确的变量名</h1><p>在确定了变量的大致意思后,应当结合语义选择更专业,准确的词,我们可以给名字附带更多的信息.比如下面这个get用的就很不好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function getPageDate()&#123;&#125;&#x2F;&#x2F;bad</span><br><span class="line">function fetchPageDate()&#123;&#125;&#x2F;&#x2F;good</span><br></pre></td></tr></table></figure><p>get表达了什么意思呢？是从本地缓存数据还是从网络中请求数据呢？这就是表达意思含糊不清,应当使用更准确的fetch来代替.<br>再比如这里有个保存颜色的变量,如果能加上对应的格式,那就更容易理解了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let color &#x3D; &#39;#FFB6C1&#39;;&#x2F;&#x2F;bad</span><br><span class="line">let hexColor &#x3D; &#39;#FFB6C1&quot;;&#x2F;&#x2F;good</span><br><span class="line">let rgbColor &#x3D; &quot;255,182,193&quot;;&#x2F;&#x2F;good</span><br></pre></td></tr></table></figure><h1 id="控制变量名的长度"><a href="#控制变量名的长度" class="headerlink" title="控制变量名的长度"></a>控制变量名的长度</h1><p>假设有一个将字符串转换为数字类型的函数,也许你会命名为convertStringToNumber,这名字的确是很准确的表达出了意思，但还是不够简练。<br>一般来说,变量名应该尽量不超过三个单词,我们可以使用一些众所周知的缩写词,例如:<br>单词|缩写<br>—|:–:<br>document|doc<br>evaluation|eval<br>current|cur<br>array|arr<br>length|len<br>string|str<br>number|num<br>但千万要注意,不应该使用自己创造的缩写词,免得给人造成困扰,比如：<br>单词|缩写<br>—|:–:<br>password|pw<br>comment|comt<br>distribute|dist<br>extract|ext<br>component|cpt<br>这样能在可读性和长度之间找到一个更好的平衡,比如上面的例子我们完全可以把它写成str2Num.更加简洁。</p><h1 id="作用域的影响"><a href="#作用域的影响" class="headerlink" title="作用域的影响"></a>作用域的影响</h1><p>一个信息量丰富的变量名总是最好的么？当然不是,变量名和作用域也是息息相关的.<br>我们都知道全局变量会污染全局环境,过多的全局变量经常会导致多人协作变量名冲突的问题,但泛泛的变量名也是全局变量带来的问题之一.<br>在ES6之前，如果我们想要避免全局变量的污染，只能将变量挂载到一个对象中，将这个对象暴露到全局中。这样做的好处就是将多个全局变量按功能进行了划分，不管是可读性还是扩展性都有不错的表现。<br>例如:在全局中有find和remove两个方法，我们可能不知道这是干什么的。但是在我们用的jQuery中，我们就很容易知道这是查询和删除DOM节点的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;bad</span><br><span class="line">let find &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line">let remove &#x3D; () &#x3D;&gt;&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;good</span><br><span class="line">$.fn.find&#x3D;()&#x3D;&gt;&#123;&#125;;</span><br><span class="line">$.fn.remove&#x3D;()&#x3D;&gt;&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;good</span><br><span class="line">(function($)&#123;</span><br><span class="line">    let find&#x3D;()&#x3D;&gt;&#123;&#125;;</span><br><span class="line">    let remove &#x3D;()&#x3D;&gt;&#123;&#125;;</span><br><span class="line">    $.fn.find&#x3D;find;</span><br><span class="line">    $.fn.remove&#x3D;remove;</span><br><span class="line">&#125;(jQuery))</span><br></pre></td></tr></table></figure><p>在ES6有了模块化规范之后，管理变量就更加容易了。一个文件就可以是一个模块，这个文件中定义的变量也不会污染全局。又因为模块都是定义好的，所以模型名也可以起到限制的作用，在模块中的变量我们都知道是和这个模块功能息息相关的。</p><p>就像上面说的一样，在局部作用域中，作用域已经起到了一部分描述的作用，那么变量名也可以适当的缩短一些。</p><p>比如有一个calcSalary的方法，在这个方法里面有一个叫total的变量，我们就很容易知道这个变量保存了计算的结果。</p><p>但如果在全局变量中有个total变量，恐怕我们就很难知道它所表达的意思了,salaryTotal也许会更加合适，这也是为什么建议大家少用全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let total;&#x2F;&#x2F;bad</span><br><span class="line">let salaryTotal;&#x2F;&#x2F;good</span><br><span class="line"></span><br><span class="line">let calcSalary&#x3D;()&#x3D;&gt;&#123;</span><br><span class="line">    let total;&#x2F;&#x2F;good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该都很喜欢在for forEach等循环中用，i,j,k都是下标值，一不小心就搞混淆了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (let i &#x3D; 0; i &lt; countries.length; i++) &#123;</span><br><span class="line">    const provinces &#x3D; countries[i].provinces;</span><br><span class="line">    for (let j &#x3D; 0; j &lt; provinces.length; j++) &#123;</span><br><span class="line">        const cities &#x3D; provinces[j].cities;</span><br><span class="line">        for (let k &#x3D; 0; k &lt; cities.length; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F; i、j、k的意义表达不够明确，很容易造成混淆。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习要注意到细节,不是粗枝大叶得,这样可以逐步学习,摸索,找到客观规律.—徐特立&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;名字是一个人在社会中必不可少的符号雨表示，也
      
    
    </summary>
    
    
    
      <category term="Web前端开发修炼指南" scheme="https://peilei6026.github.io/tags/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关命令</title>
    <link href="https://peilei6026.github.io/2020/05/15/Linux%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>https://peilei6026.github.io/2020/05/15/Linux%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</id>
    <published>2020-05-15T01:50:29.000Z</published>
    <updated>2020-06-29T15:05:10.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>将文件从第一行开始连续将文本内容输出到屏幕上</p><h1 id="sudo-crontab-e设置定时任务"><a href="#sudo-crontab-e设置定时任务" class="headerlink" title="sudo crontab -e设置定时任务"></a>sudo crontab -e设置定时任务</h1><p>定时任务的守护进程，精确到分，设计秒的我们一般写脚本–&gt;相当于闹钟<br>日志文件：|| /var/log/cron*<br>编辑文件： vim /etc/crontab<br>进程:  ps -ef | grep crond ==&gt; /etc/init.d/crond restart<br>作用：定时备份，定时备份</p><h2 id="常见命令参数"><a href="#常见命令参数" class="headerlink" title="常见命令参数"></a>常见命令参数</h2><p>usage:  crontab [-u user] file<br>        crontab [-u user] [ -e | -l | -r ]<br>                (default operation is replace, per 1003.2)<br>        -e      (edit user’s crontab)<br>        -l      (list user’s crontab)<br>        -r      (delete user’s crontab)<br>        -i      (prompt before deleting user’s crontab)<br>        -s      (selinux context)</p><p>定时任务分类</p><p>Linux下的任务调度分为两类，系统任务调度和用户任务调度。<br>    系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。<br>        在/etc/crontab文件，这个就是系统任务调度的配置文件。<br>    用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。<br>        用户可以使用 crontab 工具来定制自己的计划任务。<br>        在crontab 文件都被保存在/var/spool/cron目录中。其文件名与用户名一致</p><p>1.系统定时任务：例如清理系统日志，清理系统缓存   –&gt;不过多的关注<br>    查询系统定时处理任务的路径：<br>        路径1：<br>            cd /etc/logrotate.d/        –&gt;可以写定时任务<br>            less syslog<br>        路径2：<br>            cat /etc/crontab   –&gt;不推荐使用，但是可以看格式<br>        路径3：<br>             ls /etc/ | grep cron*<br>                 anacrontab<br>                 cron.d                 –&gt;同路径2 ，可以写定时任务<br>                 cron.daily<br>                 cron.deny              –&gt;控制普通用户使用定时任务crontab<br>                 cron.hourly<br>                 cron.monthly<br>                 crontab<br>                 cron.weekly<br>2.用户的定时任务      –&gt;关注重点<br>crontab文件内容分析<br>cat /etc/crontab</p><p>image</p><p>前四行是用来配置crond任务运行的环境变量</p><p>第一行SHELL变量指定了系统要使用哪个shell，这里是bash</p><p>第二行PATH变量指定了系统执行命令的路径</p><p>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户</p><p>如果MAILTO变量的值为空，则表示不发送任务执行信息给用户</p><p>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</p><p>星号（*）：代表所有可能的值，如month字段为星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。</p><p>小 结：<br>    数字的表示最好用2为阿拉伯数字显示<br>    周和日最好不要同时用<br>    定时任务要加注解<br>    可以定向到日志文件或者空文件<br>    定时任务一定是绝对路径，且目录必须存在才能出结果<br>    crontab 服务一定要开启运行</p><p>crontab日志路径</p><h1 id="【日志是按照天排列的】"><a href="#【日志是按照天排列的】" class="headerlink" title="【日志是按照天排列的】"></a>【日志是按照天排列的】</h1><p>ll /var/log/cron*<br>    /var/log/cron只会记录是否执行了某些计划的脚本，但是具体执行是否正确以及脚本执行过程中的一些信息则linux会每次都发邮件到该用户下。</p><p>less /var/spool/mail/root</p><p>常用的命令展示<br>安装crontab：</p><p>yum install crontabs<br>crontab服务操作说明：</p><p>/sbin/service crond start //启动服务</p><p>/sbin/service crond stop //关闭服务</p><p>/sbin/service crond restart //重启服务</p><p>/sbin/service crond reload //重新载入配置<br>查看crontab服务状态：</p><p>service crond status<br>手动启动crontab服务：</p><p>service crond status<br>查看crontab服务是否已设置为开机启动，执行命令：</p><p>方法一： 界面启动      ntsysv<br>方法二： 加入开机自动启动：   chkconfig –level 35 crond on<br>crontab -l查看定时任务列表</p><p>编辑定时任务</p><p>crontab –e</p><p>==》vim /var/spool/cron/root<br>每隔2分钟输出时间到文件</p><p>*/2 * * * * echo <code>date</code> &gt;&gt; $HOME&gt;test.txt<br>crontab -r 删除定时任务</p><p>==&gt; 从/var/spool/cron目录中删除用户的crontab文件<br>==&gt; 如果不指定用户，则默认删除当前用户的crontab文件<br> crontab –i  在删除用户的crontab文件时给确认提示<br>备份crontab文件</p><p>crontab -l &gt; $HOME/mycron</p><p>恢复丢失的crontab文件</p><p>如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：<br>crontab <filename> 其中，<filename>是你在$ H O M E目录中副本的文件名。<br>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<Ctrl-D>，否则你将丢失crontab文件。<br>每小时执行/etc/cron.hourly目录内的脚本</p><p>1<br>0 * * * * root run-parts /etc/cron.hourly<br>每隔2分钟同步一次互联网时间</p><p>1<br>echo “*/2 * * * * /usr/bin/ntpstat time.windows.com &gt;/dev/null 2&gt;&amp;1” &gt;&gt; /var/spool/cron/root</p><p>每天3-5,17-20每隔30分钟执行一次脚本</p><p>1<br>echo “*/30 [3-5],[17-20] * * * /bin/sh /home/omc/h.sh &gt;/dev/null 2&gt;&amp;1” &gt;&gt; /var/spool/cron/root</p><p>当天23点，第二天0点到凌晨7点 每隔1分钟执行一次脚本</p><p>1</p><ul><li>23,00-07/1 * * * /bin/sh /home/omc.h.sh</li></ul><p>每年的4月份每周的周一到周三的11点执行脚本   </p><p>1<br>00 11 *  4 1-3 /bin/sh /home/omc/h.sh<br>crontab的注意事项</p><ol><li>注意环境变量问题</li></ol><p>在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置</p><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p><h1 id="脚本中涉及文件路径时写全局路径；"><a href="#脚本中涉及文件路径时写全局路径；" class="headerlink" title="脚本中涉及文件路径时写全局路径；"></a>脚本中涉及文件路径时写全局路径；</h1><h1 id="脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如："><a href="#脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：" class="headerlink" title="脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如："></a>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</h1><p>cat start_cbp.sh<br>#!/bin/sh<br>source /etc/profile<br>export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf<br>/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;</p><h1 id="当手动执行脚本OK，但是crontab死活不执行时。可以尝试在crontab中直接引入环境变量解决问题。"><a href="#当手动执行脚本OK，但是crontab死活不执行时。可以尝试在crontab中直接引入环境变量解决问题。" class="headerlink" title="当手动执行脚本OK，但是crontab死活不执行时。可以尝试在crontab中直接引入环境变量解决问题。"></a>当手动执行脚本OK，但是crontab死活不执行时。可以尝试在crontab中直接引入环境变量解决问题。</h1><p>0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh<br>2. 系统级任务调度与用户级任务调度</p><p>1<br>root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。<br>3.其他注意事项</p><p>1<br>2<br>3<br>当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。<br>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。<br>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’<br>4. 生产调试定时任务</p><p>1.增加执行任务的频率调试<br>2.调整系统时间调试任务，提前5分钟   –&gt;不用于生产环境<br>3.通过脚本日志输出调试定时 任务<br>4.注意一些任务命令带来的问题        –&gt;确保命令的正确性<br>5.crontab箴言</p><p>1.环境变量问题，例如crontab不能识别Java的环境变量<br>    crontab执行shell时，只能识别为数不多的环境变量，普通的环境变量是无法识别的，所以在编写shell时，最好使用export重新声明变量，确保脚本执行。<br>2.命令的执行最好用脚本<br>3.脚本权限加/bin/sh，规范路径/server/scripts<br>4.时间变量用反斜线转义，最好用脚本<br>5.定时任务添加注释<br>6.&gt;/dev/null 2&gt;&amp;1   ==&gt;&amp;&gt;/dev/null,别随意打印日志文件<br>7.定时任务里面的程序脚本尽量用全路径<br>8.避免不必要的程序以及命令输出<br>9.定时任务之前添加注释<br>10.打包到文件目录的上一级</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cat&quot;&gt;&lt;a href=&quot;#cat&quot; class=&quot;headerlink&quot; title=&quot;cat&quot;&gt;&lt;/a&gt;cat&lt;/h1&gt;&lt;p&gt;将文件从第一行开始连续将文本内容输出到屏幕上&lt;/p&gt;
&lt;h1 id=&quot;sudo-crontab-e设置定时任务&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://peilei6026.github.io/tags/Linux/"/>
    
      <category term="学习" scheme="https://peilei6026.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSS字体</title>
    <link href="https://peilei6026.github.io/2020/05/14/CSS%E5%AD%97%E4%BD%93/"/>
    <id>https://peilei6026.github.io/2020/05/14/CSS%E5%AD%97%E4%BD%93/</id>
    <published>2020-05-14T15:19:00.000Z</published>
    <updated>2020-06-14T15:24:54.209Z</updated>
    
    <content type="html"><![CDATA[<p>CSS字体属性定义字体，加粗，大小，文字样式。</p><h2 id="CSS字型"><a href="#CSS字型" class="headerlink" title="CSS字型"></a>CSS字型</h2><p>在CSS中，有两种的类型的字体系列名称：</p><ul><li>通用字体系列-拥有相似外观的字体系统组合（如 “Serif” 或 “Monospace”）</li><li>特定字体系列-一个特定的字体系列（如 “Times” 或 “Courier”）</li></ul><table><thead><tr><th>Generic family</th><th align="center">字体系列</th><th align="right">说明</th></tr></thead><tbody><tr><td>Serif</td><td align="center">Times New Roman/Georgia</td><td align="right">Serif字体中字符在行的末端拥有额外的装饰</td></tr><tr><td>Sans-serif</td><td align="center">Arial/Verdana</td><td align="right">“Sans”是指无 - 这些字体在末端没有额外的装饰</td></tr><tr><td>Monospace</td><td align="center">Courier New/Lucida Console</td><td align="right">所有的等宽字符具有相同的宽度</td></tr></tbody></table><h2 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h2><p>font-family属性设置字体的字体系列<br>font-family属性应该设置几个字体名称作为一种“后备”机制，如果浏览器不支持第一种字体，他将尝试一种字体。<br>注意：如果字体系列的名称超过一个字，它必须用引号，如Font Family:”宋体”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;font-family:&quot;Times New Roman&quot;,Times,serif;&#125;</span><br></pre></td></tr></table></figure><p>对于较常用的字体组合，我们<a href="https://www.runoob.com/cssref/css-websafe-fonts.html" target="_blank" rel="noopener">https://www.runoob.com/cssref/css-websafe-fonts.html</a> web安全字体组合</p><h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><p>主要是用于指定斜体文字的字体样式属性。<br>这个属性有三个值：</p><ul><li>正常 - 正常显示文本</li><li>斜体 - 以斜体字显示的文字</li><li>倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.normal &#123;font-style:normal;&#125;</span><br><span class="line">p.italic &#123;font-style:italic;&#125;</span><br><span class="line">p.oblique &#123;font-style:oblique;&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS字体属性定义字体，加粗，大小，文字样式。&lt;/p&gt;
&lt;h2 id=&quot;CSS字型&quot;&gt;&lt;a href=&quot;#CSS字型&quot; class=&quot;headerlink&quot; title=&quot;CSS字型&quot;&gt;&lt;/a&gt;CSS字型&lt;/h2&gt;&lt;p&gt;在CSS中，有两种的类型的字体系列名称：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://peilei6026.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES6标准入门-阮一峰</title>
    <link href="https://peilei6026.github.io/2020/05/13/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
    <id>https://peilei6026.github.io/2020/05/13/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/</id>
    <published>2020-05-13T14:49:38.000Z</published>
    <updated>2020-05-13T15:05:51.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-let和const"><a href="#1-let和const" class="headerlink" title="1.let和const"></a>1.let和const</h1><p>暂时性死区（Temporal Dead Zone)<br>let和const命令声明的变量吴变量提升，且都会被锁定在声明的代码块中，在let和const命令行前，使用该变量都将报错，这一部分称为”暂时性死区”.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp &#x3D; 123;</span><br><span class="line"></span><br><span class="line">if(true)&#123;</span><br><span class="line">    tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F;ReferenceError</span><br><span class="line">    let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let tmp 将tmp变量绑定在 {}代码块之内，外部的tmp声明无效，tmp=’abc’就处在死去，所以报错。同理在以前没有let和const命令的时候，typeof是一个安全的运算符，即使变量没有被声明，也会正常返回undefined,但如果typeof处在死区中，处理了在后文被let和const的变量，将会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof undeclared_variable;&#x2F;&#x2F;undefined 未被let和const声明反而没事</span><br><span class="line">if(true)&#123;</span><br><span class="line">    &#x2F;&#x2F;TDZ开始 (Temporal Dead Zone: 暂时性死区)</span><br><span class="line">    typeof tmp &#x2F;&#x2F;ReferenceError</span><br><span class="line">    let tmp;&#x2F;&#x2F;TDZ结束</span><br><span class="line">    console.log(tmp);&#x2F;&#x2F;undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶层对象<br>var和function的全局声明会自动绑定到window或者global对象，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-let和const&quot;&gt;&lt;a href=&quot;#1-let和const&quot; class=&quot;headerlink&quot; title=&quot;1.let和const&quot;&gt;&lt;/a&gt;1.let和const&lt;/h1&gt;&lt;p&gt;暂时性死区（Temporal Dead Zone)&lt;br&gt;let和c
      
    
    </summary>
    
    
    
      <category term="ES6" scheme="https://peilei6026.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React面试题</title>
    <link href="https://peilei6026.github.io/2020/05/12/React%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://peilei6026.github.io/2020/05/12/React%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-05-12T14:49:12.000Z</published>
    <updated>2020-05-13T14:43:38.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是React？"><a href="#1-什么是React？" class="headerlink" title="1.什么是React？"></a>1.什么是React？</h1><p>React是一个开源的前端JavaScript库，用于构建用户界面，尤其是单页面的应用。它用与处理网页和移动应用程序的试图层.React是由Facebook的软件工程师jordan walke创建，在2011年React应用首次被部署到Facebook的信息流中，之后与2012年被应用到instagram上</p><h1 id="2-React的主要特点是什么？"><a href="#2-React的主要特点是什么？" class="headerlink" title="2.React的主要特点是什么？"></a>2.React的主要特点是什么？</h1><p>React的主要特性有：</p><ul><li>考虑到真实的DOM操作成本很高，它使用VirtualDOM不是真实的DOM.</li><li>支持服务段渲染</li><li>遵循单项数据流或者数据绑定</li><li>使用可重复/可组合的UI组件开发视图<h1 id="3-什么是JSX"><a href="#3-什么是JSX" class="headerlink" title="3.什么是JSX?"></a>3.什么是JSX?</h1>JSX是ECMAScript一个类似ML的语法扩展。基本上，他只是为了React.createElement()函数提供语法糖，从而让在我们在JavaSctipy中，使用类HTML模板的语法，进行页面描述。<br>在下面的示例中，<h1>内的文本标签会作为JavaSctipt函数返回给渲染函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component&#123;</span><br><span class="line">    return()&#123;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;&#123;&#39;Welcome to React world!&#39;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上示例render方法中的jsx将会被转换为一下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(&quot;div&quot;, null, React.createElement(&quot;h1&quot;,null,&quot;Welcome to React world!&#39;));</span><br></pre></td></tr></table></figure><h1 id="4-元素和组件有什么区别？"><a href="#4-元素和组件有什么区别？" class="headerlink" title="4.元素和组件有什么区别？"></a>4.元素和组件有什么区别？</h1>一个Element是一个简单的对象，它描述了你希望在屏幕上以DOM节点或其他组件的形式呈现的内容。Elements在他们的属性中可以包含其他的Elements。创建一个React元素是很轻量的，一旦元素被创建后，它将不会被修改。<br>React Element的对象表示如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">    &#39;div&#39;,</span><br><span class="line">    &#123;id: &#39;login-btn&#39;&#125;,</span><br><span class="line">    &#39;Login&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>上面的 React.createElement() 函数会返回一个对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;login-btn&#39;&gt;Login&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>而一个组件可以用多种不同方式声明。它可以是一个含有render()方法的类，或者，在简单的情况中，它可以定义为函数。无论哪种情况，它都将props作为输入，并返回一个JSX树作为输出。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Button &#x3D; (&#123; onLogin &#125;) &#x3D;&gt;</span><br><span class="line">    &lt;div id&#x3D;&#123;&#39;login-btn&#39;&#125; onClick&#x3D;&#123;onLogin&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure>然后JSX被转换成React.createElement()函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Button &#x3D; (&#123; onLogin &#125;) &#x3D;&gt; React.createElement(</span><br><span class="line">    &#39;div&#39;,</span><br><span class="line">    &#123;id: &#39;login-btn&#39;, onClick: onLogin &#125;,</span><br><span class="line">    &#39;Login&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="5-如何在React中创建组件？"><a href="#5-如何在React中创建组件？" class="headerlink" title="5.如何在React中创建组件？"></a>5.如何在React中创建组件？</h1>有两种可行的方法来创建一个组件：<br>i.Function Components:这是创建组件的最简单的方法，这些是纯JavaScript函数，接受props对象作为第一个参数并返回React元素：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Greetion(&#123; message &#125;)&#123;</span><br><span class="line">    return &lt;h1&gt;&#123;&#39;Hello, $&#123;message&#125;&#39;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>ii.Class Components:你还可以使用ES6类来定义组件，上面的函数组件若使用ES6的类可改写为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Greetion extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;h1&gt;&#123;&#39;Hello, $&#123;this.props.message&#125;&#39;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-如何使用类组件和函数组件？"><a href="#6-如何使用类组件和函数组件？" class="headerlink" title="6.如何使用类组件和函数组件？"></a>6.如何使用类组件和函数组件？</h1>如果组件需要使用状态或生命周期方法，那么使用类组件，否则使用函数组件。<h1 id="7-什么是Pure-Components"><a href="#7-什么是Pure-Components" class="headerlink" title="7.什么是Pure Components?"></a>7.什么是Pure Components?</h1>React.PureComponent完全相同，只是它为你处理了shouldComponetUpdate()方法。当属性或者状态发生变化时，PureComponent将对属性和状态进行浅比较。另一方面，普通组件不会将当前的属性和状态与新的属性和状态进行比较，因此，在默认情况下，每当调用shouldComponetUpdate时，组件将重新渲染。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是React？&quot;&gt;&lt;a href=&quot;#1-什么是React？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是React？&quot;&gt;&lt;/a&gt;1.什么是React？&lt;/h1&gt;&lt;p&gt;React是一个开源的前端JavaScript库，用于构建用户界面，
      
    
    </summary>
    
    
    
      <category term="React" scheme="https://peilei6026.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Refs</title>
    <link href="https://peilei6026.github.io/2020/05/11/React-Refs/"/>
    <id>https://peilei6026.github.io/2020/05/11/React-Refs/</id>
    <published>2020-05-11T14:54:46.000Z</published>
    <updated>2020-05-11T15:15:06.965Z</updated>
    
    <content type="html"><![CDATA[<p>React支持一种非常特殊的属性Ref,你可以用来绑定到render()输出的任何组件上。<br>这个特殊的属性允许你引用render()返回的相应的支撑实例(backing instance).这样就可以确保在任何事件总是拿到正确的实例。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>绑定一个ref属性到render的返回值上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref&#x3D;&quot;myInput&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>在其他代码中，通过this.refs获取支撑实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var input &#x3D; this.refs.myInput;</span><br><span class="line">var inputValue &#x3D; input.value;</span><br><span class="line">var inputRect &#x3D; input.getBoundingClientRect();</span><br></pre></td></tr></table></figure><p>你可以通过使用this来获取当前React组件，或使用ref来获取组件的引用，实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用原生的 DOM API 获取焦点</span><br><span class="line">    this.refs.myInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F;  当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;myInput&quot; &#x2F;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;button&quot;</span><br><span class="line">          value&#x3D;&quot;点我输入框获取焦点&quot;</span><br><span class="line">          onClick&#x3D;&#123;this.handleClick.bind(this)&#125;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyComponent &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实例中，我们获取了输入框的支撑实例的引用，子点击按钮后输入框获取焦点。<br>我们也可以使用getDOMNode()方法获取DOM元素</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React支持一种非常特殊的属性Ref,你可以用来绑定到render()输出的任何组件上。&lt;br&gt;这个特殊的属性允许你引用render()返回的相应的支撑实例(backing instance).这样就可以确保在任何事件总是拿到正确的实例。&lt;/p&gt;
&lt;h2 id=&quot;使用方法
      
    
    </summary>
    
    
    
      <category term="React" scheme="https://peilei6026.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React表单与事件</title>
    <link href="https://peilei6026.github.io/2020/05/09/React%E8%A1%A8%E5%8D%95%E4%B8%8E%E4%BA%8B%E4%BB%B6/"/>
    <id>https://peilei6026.github.io/2020/05/09/React%E8%A1%A8%E5%8D%95%E4%B8%8E%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-05-09T12:59:31.000Z</published>
    <updated>2020-05-11T14:46:59.921Z</updated>
    
    <content type="html"><![CDATA[<p>HTML表单元素与React中的其他DOM元素有所不同，因为表单元素生来就保留一些内部状态。<br>在HTML当中，想<input>,<textarea>,和<select>这类表单元素会维持自身状态,并根据用户输入进行更新,但在React中,可变的状态通常保存在组件的状态属性中，并且只能用setState()方法进行更新。</p><h2 id="一个简单的实例"><a href="#一个简单的实例" class="headerlink" title="一个简单的实例"></a>一个简单的实例</h2><p>在实例中我们设置了输入框input值value={this.state.data}。在输入框发生变化时我们可以更新state.我们可以使用onChange事件来监听input的变化,并修改state.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state&#x3D;&#123;value: &#39;Hello Runoob!&#39;&#125;;</span><br><span class="line">        this.handleChange&#x3D;this.handleChange.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(event)&#123;</span><br><span class="line">        this.setState(&#123;value:event.target.value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        var value &#x3D; this.state.value;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码将要渲染出一个值为Hello Runoob!的input元素，并且通过onChange事件响应更新用户输入的值。</p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p>在以下实例中我们将为大家演示如何在子组件上使用表单，onChange方法将触发state的更新并将更新的值传递到子组件的输入框的value上来重新渲染界面。<br>你需要在父组件通过创建事件句柄(handleChange)，并作为prop(updateStateProp)传递到你的子组件上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;菜鸟教程 React 实例&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;react&#x2F;15.4.2&#x2F;react.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;react&#x2F;15.4.2&#x2F;react-dom.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;babel-standalone&#x2F;6.22.1&#x2F;babel.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;example&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class="line">    var Content &#x3D; React.createClass(&#123;</span><br><span class="line">      render: function() &#123;</span><br><span class="line">        return  &lt;div&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.props.myDataProp&#125; onChange&#x3D;&#123;this.props.updateStateProp&#125; &#x2F;&gt; </span><br><span class="line">                &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    var HelloMessage &#x3D; React.createClass(&#123;</span><br><span class="line">      getInitialState: function() &#123;</span><br><span class="line">        return &#123;value: &#39;Hello Runoob!&#39;&#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      handleChange: function(event) &#123;</span><br><span class="line">        this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      render: function() &#123;</span><br><span class="line">        var value &#x3D; this.state.value;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">                &lt;Content myDataProp &#x3D; &#123;value&#125; </span><br><span class="line">                  updateStateProp &#x3D; &#123;this.handleChange&#125;&gt;&lt;&#x2F;Content&gt;</span><br><span class="line">               &lt;&#x2F;div&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">      &lt;HelloMessage &#x2F;&gt;,</span><br><span class="line">      document.getElementById(&#39;example&#39;)</span><br><span class="line">    );</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="Select下拉菜单"><a href="#Select下拉菜单" class="headerlink" title="Select下拉菜单"></a>Select下拉菜单</h2><p>在React中，不适用selected属性，而在根select标签上用value属性来表示选中项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class FlavorForm extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;value: &#39;coconut&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange&#x3D;this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit&#x3D;this.handleSumit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange(event)&#123;</span><br><span class="line">    alert(&#39;Yout facorite flavor is:&#39; +this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">   render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          选择您最喜欢的网站</span><br><span class="line">          &lt;select value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;gg&quot;&gt;Google&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;rn&quot;&gt;Runoob&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;tb&quot;&gt;Taobao&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;fb&quot;&gt;Facebook&lt;&#x2F;option&gt;</span><br><span class="line">          &lt;&#x2F;select&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;FlavorForm &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="多个表单"><a href="#多个表单" class="headerlink" title="多个表单"></a>多个表单</h2><p>当你有处理多个 input 元素时，你可以通过给每个元素添加一个 name 属性，来让处理函数根据 event.target.name 的值来选择做什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    this.handleInputChange &#x3D; this.handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target &#x3D; event.target;</span><br><span class="line">    const value &#x3D; target.type &#x3D;&#x3D;&#x3D; &#39;checkbox&#39; ? target.checked : target.value;</span><br><span class="line">    const name &#x3D; target.name;</span><br><span class="line"> </span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          是否离开:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;isGoing&quot;</span><br><span class="line">            type&#x3D;&quot;checkbox&quot;</span><br><span class="line">            checked&#x3D;&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          访客数:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;numberOfGuests&quot;</span><br><span class="line">            type&#x3D;&quot;number&quot;</span><br><span class="line">            value&#x3D;&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-事件"><a href="#React-事件" class="headerlink" title="React 事件"></a>React 事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state &#x3D; &#123;value: &#39;Hello Runoob!&#39;&#125;;</span><br><span class="line">      this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: &#39;菜鸟教程&#39;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    var value &#x3D; this.state.value;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleChange&#125;&gt;点我&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;h4&gt;&#123;value&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">           &lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当你需要从子组件中更新父组件的 state 时，你需要在父组件通过创建事件句柄 (handleChange) ，并作为 prop (updateStateProp) 传递到你的子组件上。实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Content extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return  &lt;div&gt;</span><br><span class="line">              &lt;button onClick &#x3D; &#123;this.props.updateStateProp&#125;&gt;点我&lt;&#x2F;button&gt;</span><br><span class="line">              &lt;h4&gt;&#123;this.props.myDataProp&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">           &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state &#x3D; &#123;value: &#39;Hello Runoob!&#39;&#125;;</span><br><span class="line">      this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: &#39;菜鸟教程&#39;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    var value &#x3D; this.state.value;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">            &lt;Content myDataProp &#x3D; &#123;value&#125; </span><br><span class="line">              updateStateProp &#x3D; &#123;this.handleChange&#125;&gt;&lt;&#x2F;Content&gt;</span><br><span class="line">           &lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;HelloMessage &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML表单元素与React中的其他DOM元素有所不同，因为表单元素生来就保留一些内部状态。&lt;br&gt;在HTML当中，想&lt;input&gt;,&lt;textarea&gt;,和&lt;select&gt;这类表单元素会维持自身状态,并根据用户输入进行更新,但在React中,可变的状态通常保存在组件的状态
      
    
    </summary>
    
    
    
      <category term="React" scheme="https://peilei6026.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React AJAX</title>
    <link href="https://peilei6026.github.io/2020/05/09/React-AJAX/"/>
    <id>https://peilei6026.github.io/2020/05/09/React-AJAX/</id>
    <published>2020-05-09T12:44:25.000Z</published>
    <updated>2020-05-09T12:58:58.686Z</updated>
    
    <content type="html"><![CDATA[<p>React组件的数据可以通过componentDidMount方法中的Ajax来获取,当从服务段获取数据时可以将数据存储在state中,再用this.setState方法重新渲染UI.<br>当使用异步加载数据时,再组件卸载前使用componentWillUnmount来取消未完成的请求。<br>以下实例演示了获取Github用户最新gist共享描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class UserGist extends React.Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.stat&#123;username: &#39;&#39;,lastGistUrl:&#39;&#39;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        this.serverRequest &#x3D; $.get(this.props.source, function(result)&#123;</span><br><span class="line">            var lastGist &#x3D; resule[0];</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                username: lastGist.owner.login,</span><br><span class="line">                lastGistUrl: lastGist.html_url</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        this.serverRequest.abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;this.state.username&#125;用户最新的Gist共享地址：</span><br><span class="line">                &lt;a href&#x3D;&#123;this.state.lastGistUrl&#125;&gt;&#123;this.state.lastGistUrl&#125;&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;UserGist soure&#x3D;&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;octocat&#x2F;gists&quot;&#x2F;&gt;,</span><br><span class="line">    document.getElementBtId(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以上代码使用jQuery完成Ajax请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React组件的数据可以通过componentDidMount方法中的Ajax来获取,当从服务段获取数据时可以将数据存储在state中,再用this.setState方法重新渲染UI.&lt;br&gt;当使用异步加载数据时,再组件卸载前使用componentWillUnmount来取
      
    
    </summary>
    
    
    
      <category term="React" scheme="https://peilei6026.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React组件生命周期</title>
    <link href="https://peilei6026.github.io/2020/05/08/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://peilei6026.github.io/2020/05/08/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-05-08T15:49:45.000Z</published>
    <updated>2020-05-08T16:25:39.061Z</updated>
    
    <content type="html"><![CDATA[<p>在本章节我们将讨论React组件的生命周期。<br>组件的生命周期可分成三个状态：</p><ul><li>Mounting:已插入真实DOM</li><li>Updating:正在被重新渲染</li><li>Unmounting:已移出真实DOM<br>生命周期的方法有：</li><li>componentWillMount在渲染前调用，在客户端也在服务端。</li><li>componentDidMOunt:在第一次渲染后调用，只在客户端，之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。如果你想和其他的JavaScript框架一起使用，可以在这个方法中调用setTimeout,setlnterval或者发送AJAX请求等操作（防止异步操作阻塞UI)</li><li>componentWillReceiveProps在组件接受到一个新的prop(更新后)时被调用，这个方法在初始话render时不会被调用。</li><li>shouldComponentUpdate返回一个布尔值，在组件接受到新的props或者state时被调用，在初始化时或者使用forceUpdate时不被调用。<br>可以在你确认不需要更新组件时使用。</li><li>componentWillUpdate在组件接受到新的props或者state但还没有render时被调用。在初始化时不会被调用。</li><li>componentDidUpdate在组件完成更新后立即调用。在初始化时不会被调用。</li><li>componentWillUnmount在组件从DOM中移除之前立即被调用。<br>以下实例在Hello组件加载以后，通过componentDidMount方法设置一个定时器，每隔100毫秒重新设置组建的透明度，并重新渲染：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line"> </span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state &#x3D; &#123;opacity: 1.0&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.timer &#x3D; setInterval(function () &#123;</span><br><span class="line">      var opacity &#x3D; this.state.opacity;</span><br><span class="line">      opacity -&#x3D; .05;</span><br><span class="line">      if (opacity &lt; 0.1) &#123;</span><br><span class="line">        opacity &#x3D; 1.0;</span><br><span class="line">      &#125;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        opacity: opacity</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;.bind(this), 100);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style&#x3D;&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt;</span><br><span class="line">        Hello &#123;this.props.name&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Hello name&#x3D;&quot;world&quot;&#x2F;&gt;,</span><br><span class="line">  document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>以下实例初始化state,setNuwnumber用于更新state.所有生命周期在Content组件中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Button extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state&#x3D;&#123;data:0&#125;;</span><br><span class="line">        this.setNewNumer&#x3D;this.setNewNumber.bing(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setNewNumber()&#123;</span><br><span class="line">        this.serState(&#123;data: this.state.date +1&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.setNewNumber&#125;&gt;INCREMENT&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;Content myNumber&#x3D;&#123;this.state.data&#125;&gt;&lt;&#x2F;Content&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Content extends React.Component&#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        console.log(&#39;Component WILL MOUNT!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        console.log(&#39;Component DID MOUNT!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(newProps)&#123;</span><br><span class="line">        console.log(&#39;Component WILL RECEIVE PROPS!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate(newProps, newState)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUpdate(nextProps,nextState)&#123;</span><br><span class="line">        console.log(&#39;Component WILL UPDATE!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate(prevProps, prevState)&#123;</span><br><span class="line">        console.log(&#39;Component DID UPDATE!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        console.log(&#39;Component WILL NUMOUNT!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123;this.props.myNumber&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Button &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;,</span><br><span class="line">    document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本章节我们将讨论React组件的生命周期。&lt;br&gt;组件的生命周期可分成三个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mounting:已插入真实DOM&lt;/li&gt;
&lt;li&gt;Updating:正在被重新渲染&lt;/li&gt;
&lt;li&gt;Unmounting:已移出真实DOM&lt;br&gt;生命周期的方
      
    
    </summary>
    
    
    
      <category term="React" scheme="https://peilei6026.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React组件API</title>
    <link href="https://peilei6026.github.io/2020/05/07/React%E7%BB%84%E4%BB%B6API/"/>
    <id>https://peilei6026.github.io/2020/05/07/React%E7%BB%84%E4%BB%B6API/</id>
    <published>2020-05-07T13:59:10.000Z</published>
    <updated>2020-05-08T15:48:40.490Z</updated>
    
    <content type="html"><![CDATA[<p>在本章节中我们将讨论React组件API.我们将讲解一下7个方法：</p><ul><li>设置状态:setState</li><li>替换状态:replaceState</li><li>设置属性:setProps</li><li>替换属性:replaceProps</li><li>强制更新:forceUpdate</li><li>获取DOM节点:findDOMNode</li><li>判断组件挂载状态:isMounted<h2 id="设置状态setState"><a href="#设置状态setState" class="headerlink" title="设置状态setState"></a>设置状态setState</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(object nextState[, function callback])</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3></li><li>nextState,将要设置得新状态，该状态会和当前得state合并</li><li>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。<br>合并nextState和当前state,并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新得主要方法。<h3 id="关于setState"><a href="#关于setState" class="headerlink" title="关于setState"></a>关于setState</h3>不能再组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。<br>setState()并不会立即改变this.state,而是创建一个即将处理的state.setState()并不一定是同步得，为了提升性能React会批量执行state和DOM渲染。<br>setState()总是会出发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Counter extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;clickCount: 0&#125;;</span><br><span class="line">        this.handleClick &#x3D; this.handleClick.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick()&#123;</span><br><span class="line">        this.setState(function(state)&#123;</span><br><span class="line">            return &#123;clickCount: state.clickCount + 1&#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (&lt;h2 onClick&#x3D;&#123;this.handleClick&#125;&gt;点我！点击次数为:&#123;this.state.clickCount&#125;&lt;&#x2F;h2&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Counter &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>实例中通过点击h2标签来使得点击计数器加1<h2 id="替换状态：replaceState"><a href="#替换状态：replaceState" class="headerlink" title="替换状态：replaceState"></a>替换状态：replaceState</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replaceState(object nextState[, function call back])</span><br></pre></td></tr></table></figure></li><li>nextState,将要设置的新状态，该状态会替换当前的state.</li><li>callback,可选参数，回调函数，该函数会在replaceState设置成功，且组件重新渲染后调用。<br>设置组件属性，并重新渲染组件。<br>props相当于组件的数据量，它总会从父组件向下传递至所有的子组件中，当和一个外部的JavaScript应用集成时，我们可能会需要想组件传递数据或者通知React.render()组件需要重新渲染，可以使用setProps().<br>更新组件，我可以在节点上再次调用React.render(),也可以通过setProps()方法改变组件属性，出发组件重新渲染。<h2 id="替换属性-replaceProps"><a href="#替换属性-replaceProps" class="headerlink" title="替换属性:replaceProps"></a>替换属性:replaceProps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replaceProps(object nextProps[, function callback])</span><br></pre></td></tr></table></figure></li><li>nextProps,将要设置的新属性，该属性会替换当前的props.</li><li>callback,可选参数，回调函数，该函数会在replaceProps设置成功，且组件重新渲染后调用。<br>replaceProps()方法与setProps类似，但它会删除原有的props.<h2 id="强制更新-forceUpdate"><a href="#强制更新-forceUpdate" class="headerlink" title="强制更新:forceUpdate"></a>强制更新:forceUpdate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forceUpdate([function callback])</span><br></pre></td></tr></table></figure>参数说明</li><li>callback,可选参数，回调函数，该函数会在组件render()方法调用后调用。<br>forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render(),但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。<br>forceUpdate()方法适用于this.props和this.state之外的组件重绘（如:修改了this.state后),通过该方法通知React需要调用render()<br>一般来说，应该尽量避免使用forceUpdate(),而仅从this.props和this.state中读取状态并由React触发render()调用<h2 id="获取DOM节点-findDOMNode"><a href="#获取DOM节点-findDOMNode" class="headerlink" title="获取DOM节点:findDOMNode"></a>获取DOM节点:findDOMNode</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMElement fundDOMNode()</span><br></pre></td></tr></table></figure></li><li>返回值：DOM元素DOMElement<br>如果组件已经挂载到DOM中，该方法返回对应的本地浏览器DOM元素。当render返回null或false时，this.findDOMNode()也会返回null，从DOM中读取值得时候，该方法很有用，如：获取表单字段的值和做一些DOM操作。<h2 id="判断组件挂载状态-isMounted"><a href="#判断组件挂载状态-isMounted" class="headerlink" title="判断组件挂载状态:isMounted"></a>判断组件挂载状态:isMounted</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isMounted()</span><br></pre></td></tr></table></figure></li><li>返回值：true或false,表示组件是否已挂载到DOM中<br>isMounted()方法用于判断组件是否已挂载DOM中，可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错</li></ul><h2 id="关于setState-有三件事情要知道"><a href="#关于setState-有三件事情要知道" class="headerlink" title="关于setState()有三件事情要知道"></a>关于setState()有三件事情要知道</h2><h3 id="1、不要直接更新状态"><a href="#1、不要直接更新状态" class="headerlink" title="1、不要直接更新状态"></a>1、不要直接更新状态</h3><p>例如，此代码不会重新渲染组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;wrong</span><br><span class="line">this.state.comment &#x3D; &#39;Hello&#39;;</span><br></pre></td></tr></table></figure><p>应当使用setState();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;corect</span><br><span class="line">this.setState(&#123;comment:&#39;Hello&#39;&#125;);</span><br></pre></td></tr></table></figure><p>构造函数是唯一能够初始化this.state的地方</p><h3 id="2-状态更新可能是异步的"><a href="#2-状态更新可能是异步的" class="headerlink" title="2,状态更新可能是异步的"></a>2,状态更新可能是异步的</h3><p>React可以将多个setState()调用合成并一个调用来提高性能。<br>因为this.props和this.state可能是异步更新的，你不应该依靠他们的值来计算下一个状态。<br>例如，此代码无法更新计数器；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">    counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要修复它，请使用第二种形式的setState()来接受一个函数而不是一个对象。该函数将接受先前的状态作为第一个参数，将此次更新被应用时的props作为第二个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Correct</span><br><span class="line">this.setState((prevState, props)&#x3D;&gt;(&#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>上方代码使用了箭头函数，但它也使用于常规函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Correct</span><br><span class="line">this.setState(function(prevState, props)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        counter: prevState.counter + props.increment</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-状态更新合并"><a href="#3-状态更新合并" class="headerlink" title="3,状态更新合并"></a>3,状态更新合并</h3><p>当你调用setState()时，React将你提供的对象合并到当前状态。例如，你的状态可能包含一些独立的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state&#x3D;&#123;</span><br><span class="line">        posts:[],</span><br><span class="line">        comments:[]</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以调用setState()独立地更新他们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    fetchPosts().then(response &#x3D;&gt;&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            posts: response.posts</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fetchComments().then(response &#x3D;&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            comments: response.comments</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的合并时浅合并，也就是说this.setState({comments})完整保留了this.state.posts,但完全替换了this.state.comments.<br>isMounted的方法在ES6中已经废除了。主要的原因是它经过实际与测试可能不足以检测组件是否挂载，尤其是对于有一些异步的程序情况，以及逻辑上造成混乱。现在用以下方法替代；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    this.mounted&#x3D;true;</span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">    this.mounted&#x3D;false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本章节中我们将讨论React组件API.我们将讲解一下7个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置状态:setState&lt;/li&gt;
&lt;li&gt;替换状态:replaceState&lt;/li&gt;
&lt;li&gt;设置属性:setProps&lt;/li&gt;
&lt;li&gt;替换属性:replaceProps
      
    
    </summary>
    
    
    
      <category term="React" scheme="https://peilei6026.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>CSS文本格式</title>
    <link href="https://peilei6026.github.io/2020/04/29/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/"/>
    <id>https://peilei6026.github.io/2020/04/29/CSS%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-04-29T15:12:35.000Z</published>
    <updated>2020-05-14T15:17:54.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h1><p>颜色属性被用来设置文字的颜色<br>颜色是通过CSS最经常的指定；</p><ul><li>十六进制值-如：#FF0000</li><li>一个RGB值-如:RGB(255,0,0)</li><li>颜色的名称-如：red<br>一个网页的背景颜色是指在主体内的选择：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;color:red;&#125;</span><br><span class="line">h1 &#123;color:#00ff00;&#125;</span><br><span class="line">h2 &#123;color:rgb(255,0,0);&#125;</span><br></pre></td></tr></table></figure>对于W3C标准的CSS:如果你定义了颜色属性，你还必须定义背景色属性。<h1 id="文本的对齐方式"><a href="#文本的对齐方式" class="headerlink" title="文本的对齐方式"></a>文本的对齐方式</h1>文本排列属性是用于设置文本的水平对齐方式。<br>文本可居中或对齐到左或右，两端对齐。<br>当text-align设置为”justify”,每一行被展开宽度相等，左，右外边距是对齐（如杂志和报纸）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;text-align:center;&#125;</span><br><span class="line">p.date &#123;text-align:right;&#125;</span><br><span class="line">p.main &#123;text-align:justify;&#125;</span><br></pre></td></tr></table></figure><h2 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h2>text-decoration属性用来设置或删除文本的装饰。<br>从设计的角度看text-decoration属性主要是用来删除链接的下滑线：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#123;text-decoration:none;&#125;</span><br></pre></td></tr></table></figure>也可以这样装饰文字：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;text-decoration:overline;&#125;</span><br><span class="line">h2 &#123;text-decoration:line-through;&#125;</span><br><span class="line">h3 &#123;text-decoration:underline;&#125;</span><br></pre></td></tr></table></figure>我们不建议强调指出不是链接的文本，因为这常常混淆用户。<h1 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h1>文本转换属性是用来指定在一个文本中的大写和小写字母。<br>可用于所有字句变成大写或小写字母，或每个单词的首字母大写。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.uppercase &#123;text-transform:uppercase;&#125;</span><br><span class="line">p.lowercase &#123;text-transform:lowercase;&#125;</span><br><span class="line">p.capitalize &#123;text-transform:capitalize;&#125;</span><br></pre></td></tr></table></figure><h1 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h1>文本缩进属性是用来指定文本的第一行的缩进。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;text-indent:50px;&#125;</span><br></pre></td></tr></table></figure>属性|描述</li></ul><p>–|–:<br>color|设置文本颜色<br>direction|设置文本方向<br>letter-spacing|设置字符间距<br>line-height|设置行高<br>text-align|对齐元素中的文本<br>text-decoration|向文本添加修饰<br>text-indent|缩进元素中文本的首行<br>text-shadow|设置文本阴影<br>text-transform|控制元素中的字母<br>unicode-bidi|设置或返回文本是否被重写<br>vertical-align|设置元素的垂直对齐<br>white-space|设置元素中空白的处理方式<br>world-spacing|设置字间距</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文本颜色&quot;&gt;&lt;a href=&quot;#文本颜色&quot; class=&quot;headerlink&quot; title=&quot;文本颜色&quot;&gt;&lt;/a&gt;文本颜色&lt;/h1&gt;&lt;p&gt;颜色属性被用来设置文字的颜色&lt;br&gt;颜色是通过CSS最经常的指定；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;十六进制值-如：#FF0000
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://peilei6026.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS背景</title>
    <link href="https://peilei6026.github.io/2020/04/29/CSS%E8%83%8C%E6%99%AF/"/>
    <id>https://peilei6026.github.io/2020/04/29/CSS%E8%83%8C%E6%99%AF/</id>
    <published>2020-04-29T09:10:23.000Z</published>
    <updated>2020-04-29T14:56:12.401Z</updated>
    
    <content type="html"><![CDATA[<p>CSS背景属性用于定义HTML元素的背景。<br>CSS属性定义背景效果：</p><ul><li>background 简写属性，作用是将背景属性设置在一个声明中。</li><li>background-color 设置元素的背景颜色。</li><li>background-image 把图像设置为背景。</li><li>background-repeat 设置背景图像是否及如何重复</li><li>background-attachment 背景图像是否固定或者随着页面的其余部分滚动。</li><li>background-position 设置背景图像的起始位置。<h2 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h2>background-color属性定义了元素的背景颜色<br>页面的背景颜色使用在body的选择器中<br>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background-color:#b0c4de;&#125;</span><br></pre></td></tr></table></figure>CSS中，颜色值通常以以下方式定义</li><li>十六进制-如”#ff0000”</li><li>RGB-如：”rgb(255,0,0)”</li><li>颜色名称-如：”red”<br>以下实例中，h1,p,和div元素拥有不同的背景颜色<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;background-color:#6495ed;&#125;</span><br><span class="line">p &#123;background-color:#e0ffff;&#125;</span><br><span class="line">div &#123;background-color:#b0c4de;&#125;</span><br></pre></td></tr></table></figure><h2 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h2>background-image属性描述了元素的背景图像。<br>默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body&#123;background-image:url(&#39;paper.gif&#39;);&#125;</span><br></pre></td></tr></table></figure>下面时一个例子是一个糟糕的文字和背景图选组合。文本可读性差；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background-image:url(&#39;bgdesert.jpg&#39;);&#125;</span><br></pre></td></tr></table></figure><h2 id="背景图像-水平或者垂直平铺"><a href="#背景图像-水平或者垂直平铺" class="headerlink" title="背景图像-水平或者垂直平铺"></a>背景图像-水平或者垂直平铺</h2>默认情况下background-image属性会在页面的水平或者垂直方向平铺。<br>一些图像如果在水平方向与垂直反向平铺，这样看起来很不协调，如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background-image:url(&#39;gradient2.png&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果图像只在水平方向平铺(repeat-x),页面背景会更好些；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">&#123;</span><br><span class="line">    background-image:url(&#39;gradient2.png&#39;);</span><br><span class="line">    background-repeat:repeat-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背景图像-设置定位与不平铺"><a href="#背景图像-设置定位与不平铺" class="headerlink" title="背景图像-设置定位与不平铺"></a>背景图像-设置定位与不平铺</h2>让背景图片不影响文本的排版<br>如果你不想让图像平铺，你可以使用background-repeat属性：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background-image:url(&#39;img_tree.png&#39;);</span><br><span class="line">    background-repeat:no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上实例中，背景图片与文本显示在同一个位置，为了让页面排版更加合理，不影响文本的阅读，我们可以改变图像的位置。<br>可以利用background-position属性改变图片在背景中的位置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body</span><br><span class="line">&#123;</span><br><span class="line">background-image:url(&#39;img_tree.png&#39;);</span><br><span class="line">background-repeat:no-repeat;</span><br><span class="line">background-position:right top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背景-简写属性"><a href="#背景-简写属性" class="headerlink" title="背景-简写属性"></a>背景-简写属性</h2>在以上实例中我们可以看到页面的背景颜色通过了很多的属性来控制。为了简化这些属性的代码，我们可以将这些属性合并在同一属性中，<br>背景颜色的简写属性为’background”;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background:#ffffff url(&#39;img_tree.png&#39;) no-repeat right top;&#125;</span><br></pre></td></tr></table></figure>当使用简写属性时，属性值的顺序为：</li><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position<br>以上属性无需全部使用，你可以按照页面的实际需要使用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS背景属性用于定义HTML元素的背景。&lt;br&gt;CSS属性定义背景效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;background 简写属性，作用是将背景属性设置在一个声明中。&lt;/li&gt;
&lt;li&gt;background-color 设置元素的背景颜色。&lt;/li&gt;
&lt;li&gt;backgr
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://peilei6026.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS多重样式优先级深入概念</title>
    <link href="https://peilei6026.github.io/2020/04/29/CSS%E5%A4%9A%E9%87%8D%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E6%B7%B1%E5%85%A5%E6%A6%82%E5%BF%B5/"/>
    <id>https://peilei6026.github.io/2020/04/29/CSS%E5%A4%9A%E9%87%8D%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E6%B7%B1%E5%85%A5%E6%A6%82%E5%BF%B5/</id>
    <published>2020-04-29T08:41:34.000Z</published>
    <updated>2020-04-29T09:10:10.694Z</updated>
    
    <content type="html"><![CDATA[<p>优先级是浏览器通过判断哪些元素值与元素最相关以决定并应用到该元素上的。优先级仅由选择器组成的匹配规则决定的。<br>优先级就是分配给指定的CSS声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。</p><h2 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h2><p>优先级逐级增加的选择器列表</p><ul><li>通用选择器（*）</li><li>元素(类型)选择器</li><li>类选择器</li><li>属性选择器</li><li>伪类</li><li>ID选择器</li><li>内联样式<h2 id="！important规则例外"><a href="#！important规则例外" class="headerlink" title="！important规则例外"></a>！important规则例外</h2>当！important规则被应用在一个样式声明中的时候，该样式声明会覆盖CSS中任何其他的声明，无论它处在声明列表中的哪里，尽管如此，!important规则还是与优先级毫无关系，使用!important不是一个好习惯，因为它改变了你样式表本来的级联规则，从而使其难以调试。<br>一些经验规则：</li><li>Always 要优化考虑使用样式规则的优先级来解决问题而不是!important</li><li>Only只在需要覆盖全站或者外部CSS（例如引用的ExtJs或者YUI）的特定页面中使用!important</li><li>Never永远不要在全站范围的CSS上使用!important</li><li>Never 永远不要在你的插件中使用!important<br>权重计算<br>内联样式1000+id选择器100+类选择器10+元素选择器1</li></ul><h2 id="CSS优先级法则："><a href="#CSS优先级法则：" class="headerlink" title="CSS优先级法则："></a>CSS优先级法则：</h2><ul><li>A选择器都有一个权值，权值越大越优先；</li><li>B当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</li><li>C创作者的规则高于浏览者，即网页编写者设置的css样式的优先权高于浏览器所设置的样式；</li><li>D继承的CSS样式不如后面指定的CSS样式；</li><li>E在同一组属性设置中标有!important规则的优先级最大</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;优先级是浏览器通过判断哪些元素值与元素最相关以决定并应用到该元素上的。优先级仅由选择器组成的匹配规则决定的。&lt;br&gt;优先级就是分配给指定的CSS声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。&lt;/p&gt;
&lt;h2 id=&quot;优先级顺序&quot;&gt;&lt;a href=&quot;#优先级
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="https://peilei6026.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>
